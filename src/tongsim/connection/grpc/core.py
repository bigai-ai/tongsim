"""
connection.grpc.core

Provides a thin wrapper around gRPC.aio channels and service stubs via
``GrpcConnection``.

Highlights:
- Discover service stubs dynamically through ``iter_all_grpc_stubs``.
- Offer a uniform interface for retrieving and closing stub instances.
"""

from typing import TypeVar

import grpc.aio

from tongsim.logger import get_logger

from .utils import iter_all_grpc_stubs

_logger = get_logger("gRPC")

T = TypeVar("T")  # Help type-checking for get_stub callers.


class GrpcConnection:
    """
    Lazily instantiate gRPC stubs and provide unified access plus teardown.
    """

    def __init__(self, endpoint: str = "localhost:5726"):
        self._endpoint = endpoint
        self._channel: grpc.aio.Channel | None = grpc.aio.insecure_channel(
            self._endpoint,
            options=[
                ("grpc.max_send_message_length", 100 * 1024 * 1024),
                ("grpc.max_receive_message_length", 100 * 1024 * 1024),
            ],
        )
        self._stubs: dict[type[object], object] = {}
        self._initialize()

    def _initialize(self):
        """Load and instantiate all gRPC stubs from the API protocol package."""
        for _service_name, stub_cls in iter_all_grpc_stubs():
            try:
                _logger.debug(f"GrpcConnection instantiate stub: {_service_name}")
                self._stubs[stub_cls] = stub_cls(self._channel)
            except Exception as e:
                raise RuntimeError(
                    f"GrpcConnection failed to instantiate stub: {_service_name}. {e}"
                ) from e

    def __enter__(self):
        raise RuntimeError("GrpcConnection must be used with 'async'")

    def __exit__(self, exc_type, exc_val, exc_tb):
        raise RuntimeError("GrpcConnection must be used with 'async'")

    def get_stub(self, stub_cls: type[T]) -> T:
        """
        Retrieve the stub instance for the requested service.

        Args:
            stub_cls: Stub class generated by ``*_pb2_grpc.py`` (for example
                ``ExampleServiceStub``).

        Returns:
            T: Stub instance typed to ``stub_cls``.
        """
        if stub_cls not in self._stubs:
            raise ValueError(f"[GrpcConnection] Stub {stub_cls.__name__} not found.")
        return self._stubs[stub_cls]

    def __del__(self):
        if self._channel:
            _logger.error("GrpcConnection was not properly closed.")

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.aclose()

    async def aclose(self):
        """Close the gRPC channel and release all cached stubs."""
        if self._channel:
            await self._channel.close()
            self._channel = None
            _logger.debug(f"[GrpcConnection {self._endpoint}] closed channel")
        self._stubs.clear()
